#!/bin/bash

# TODO complete documentation
help() {
	cat <<EOF

$EXEC_NAME version $VERSION

Usage:
 $EXEC_NAME [options] HOST

Checks to see is if an iRODS service is online. If it connects to iRODS, it
prints "up|time=<resp-time>s" to standard output where <resp-time> is the time
it took for iRODS to respond, and it exits with status code 0. If it doesn't
connect to anything, it prints "down" to standard output and exits with status
code 1. If it connects to something that isn't iRODS, it prints "not iRODS" and
exits with status code 2.

The rodsLog will show a connection from the host where this is run with the
proxy user set to "$EXEC_NAME". If SERVICE is specified, the client user will
be set to SERVICE instead. If ZONE is specificed, the zone for both users will
be ZONE.

If \`ips\` happens to be called while this is program is connected to iRODS, \`ips\`
will show this program's connection as comming from "$EXEC_NAME".

Parameters:
 HOST  the FQDN or IP address of the server hosting the service

Options:
 -h, --help             show help and exit
 -P, --port PORT        the TCP port the iRODS iserver listens to on HOST
                        (default 1247)
 -S, --service SERVICE  the name of the service checking iRODS, identified as
                        client user to iRODS
 -V, --verbose          show the XML message returned from HOST instead of
                        default response
 -v, --version          show version and exit
 -Z, --zone ZONE        the name of the zone to tell iRODS this program and
                        SERVICE belong to.

Â© 2019, The Arizona Board of Regents on behalf of The University of Arizona. For
license information, see https://cyverse.org/license.
EOF
}


readonly VERSION=4

set -o errexit -o nounset -o pipefail

readonly DEFAULT_PORT=1247
readonly EXEC_NAME="$(basename "$(realpath --canonicalize-missing "$0")")"


main() {
	declare -A argMap=(
		[help]=''
		[ies]=''
		[port]="$DEFAULT_PORT"
		[service]="$EXEC_NAME"
		[verbose]=''
		[version]=''
		[zone]='' )

	# TODO handle return code 2
	if ! map_args argMap "$@"; then
		help >&2
		return 1
	fi

	if [[ -n "${argMap[help]}" ]]; then
		help
		return 0
	fi

  if [[ -n "${argMap[version]}" ]]; then
		printf '%s\n' "$VERSION"
		return 0
	fi

	ping \
		"${argMap[ies]}" "${argMap[port]}" "${argMap[service]}" "${argMap[zone]}" "${argMap[verbose]}"
}


# TODO describe mapVar
# resolves the command line arguments
# Arguments:
#  The first argument is the name of the associative array where the resolved
#  arguments will be store. The remaining arguments hold the raw command line
#  arguments to resolve.
# Output:
#  Any issues with the command line arguments will be written to stderr.
# Return:
#  It returns the following codes.
#   0 on success
#   1 if the command line arguments don't make sense
#   2 if an internal error occured
map_args() {
	local mapVar="$1"
	shift

	eval set -- "$(format_opts "$@")"

	while true; do
		case "$1" in
			-h|--help)
				eval "$mapVar""[help]=help"
				shift
				;;
			-P|--port)
				eval "$mapVar""[port]='$2'"
				shift 2
				;;
			-S|--service)
				eval "$mapVar""[service]='$2'"
				shift 2
				;;
			-V|--verbose)
				eval "$mapVar""[verbose]=verbose"
				shift
				;;
			-v|--version)
				eval "$mapVar""[version]=version"
				shift
				;;
			-Z|--zone)
				eval "$mapVar""[zone]='$2'"
				shift 2
				;;
			--)
				shift
				break
				;;
		esac
	done

	if [[ "$#" -lt 1 ]]; then
		printf 'IES required\n' >&2
		return 1
	fi

	eval "$mapVar""[ies]='$1'"
}


# TODO inline this function
# formats the command line options using `getopt`
# Arguments:
#  the raw command line arguments
# Output:
#  It writes the command line arguments as generated by `getopt` to stdout. Any
#  errors are written to stderr.
# Return:
#  It returns the following codes.
#   0  on success
#   1  if the command line options don't make sense
#   2  if an internal error occured
format_opts() {
	set +o errexit
	getopt \
		--name "$EXEC_NAME" \
		--longoptions help,port:,service:,verbose,version,zone: \
		--options hP:S:VvZ: \
		-- "$@"
	local rc=$?
	set -o errexit

	if (( rc > 1 )); then
		return 2
	else
		return $rc
	fi
}


ping() {
	local ies="$1"
	local port="$2"
	local service="$3"
	local zone="$4"
	local verbose="$5"

	local startTime
	startTime="$(date +'%s.%N')"

	if ! exec 3<>/dev/tcp/"$ies"/"$port"; then
		printf 'down\n'
		return 1
	fi

	local connMsgBody
	connMsgBody="$(mk_startup_pack "$service" "$zone")"

	if mk_req RODS_CONNECT "$connMsgBody" >&3; then
		local respMsg
		if respMsg="$(parse_resp <&3)"; then
			local stopTime
			stopTime="$(date +'%s.%N')"

			mk_req RODS_DISCONNECT >&3
			close_conn

			if [[ -z "$verbose" ]]; then
				local dt
				dt="$(awk --assign START="$startTime" --assign STOP="$stopTime" \
					'BEGIN { print (STOP - START) }')"

				printf 'up|time=%ss\n' "$dt"
			else
				printf '%s\n' "$respMsg"
			fi

			return 0
		fi
	fi

	close_conn
	printf 'not iRODS\n'
	return 2
}


close_conn() {
	exec 3<&-
	exec 3>&-
}


mk_req() {
	local msgType="$1"

	local msg=
	if [[ $# -ge 2 ]]; then
		msg="$2"
	fi

	local header
	header="$(mk_header "$msgType" ${#msg})"

	encode_header_len ${#header}
	printf '%s%s' "$header" "$msg"
}


parse_resp() {
	local headerLen
	headerLen="$(decode_header_len)"

	local header
	read -r -d '' -n "$headerLen" header

	if ! [[ "$header" =~ ^\<MsgHeader_PI\>.*\<type\>RODS_VERSION\</type\>.*\<msgLen\>[0-9]+\< ]]; then
		return 1
	fi

	local msgLen="${header#*<msgLen>}"
	msgLen="${msgLen%%<*}"

	local msg
	read -r -d '' -n "$msgLen" msg
	printf '%s' "$msg"
}


mk_header() {
	local type="$1"
	local msgLen="$2"

	cat <<EOX
<MsgHeader_PI>
	<type>$type</type>
	<msgLen>$msgLen</msgLen>
	<errorLen>0</errorLen>
	<bsLen>0</bsLen>
</MsgHeader_PI>
EOX
}


mk_startup_pack() {
	local clientUser="$1"
	local rcatZone="$2"

	cat <<EOX
<StartupPack_PI>
	<connectCnt>0</connectCnt>
	<proxyUser>$EXEC_NAME</proxyUser>
	<proxyRcatZone>$rcatZone</proxyRcatZone>
	<clientUser>$clientUser</clientUser>
	<clientRcatZone>$rcatZone</clientRcatZone>
	<relVersion></relVersion>
	<apiVersion></apiVersion>
	<option>$EXEC_NAME</option>
</StartupPack_PI>
EOX
}


encode_header_len() {
	local len="$1"

	printf '0: %.8x' "$len" | xxd -revert -g 0
}


# Decodes a serialized iRODS protocol packet header length
# Input:
#   the serialized length
# Output:
#   the decimal value to stdout.
decode_header_len() {
	local lenHex
	lenHex="$(od --address-radix n --format x1 --read-bytes 4 | tr --delete ' ')"

	printf '%d' $((16#$lenHex))
}


main "$@"
