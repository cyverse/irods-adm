#!/bin/bash

# TODO bring options in line with Nagios guidelines. See
#  https://nagios-plugins.org/doc/guidelines.html#PLUGOPTIONS
#    3. Add -? option that doesn't generate error
#    4. Bring --help in line
#    5. Bring --verbose in line
# TODO bring output in line with guidelines. See
#  https://nagios-plugins.org/doc/guidelines.html#PLUGOUTPUT
help() {
	# TODO review possible error codes
	cat <<EOF

$(print_version)

$(print_usage)

Nagios plugin that checks to see is if an iRODS server is online. It supports
Nagios version 2 or later and iRODS version 4 or later.

Parameters:
 HOST  the FQDN or IP address of the server hosting the service

Options:
 -h, --help             show help and exit
 -P, --port PORT        the TCP port the iRODS server listens to on HOST
                        (default 1247)
 -S, --service SERVICE  the name of the service checking iRODS, identified as
                        client user to iRODS
 -v, --verbose          show the XML message returned from HOST instead of
                        default response
 -V, --version          show version and exit
 -Z, --zone ZONE        the name of the zone to tell iRODS this program and
                        SERVICE belong to.

Output:
 Unless otherwise indicated, it writes the status of the iRODS service on HOST
 to stdout in a form interpretable by nagios.

Side Effects:
 The rodsLog will show a connection from the host where this is run with the
 proxy user set to "$EXEC_NAME". If SERVICE is specified, the client user will
 be set to SERVICE instead. If ZONE is specificed, the zone for both users will
 be ZONE.

 If \`ips\` happens to be called while this is program is connected to iRODS,
 \`ips\` will show this program's connection as comming from "$EXEC_NAME".

Exit Status:
 0  connected to iRODS
 2  failed to connect to iRODS
 3  an error occurred or connected to something other than iRODS

Â© 2019, 2021 The Arizona Board of Regents on behalf of The University of
Arizona. For license information, see https://cyverse.org/license.
EOF
}


# displays a short usage statement
print_usage() {
	cat <<EOF
Usage:
 $EXEC_NAME [-v|--vebose][(-P|--port) PORT][(-S|--service) SERVICE]
  [(-Z|--zone) ZONE] IES
 $EXEC_NAME (-h|--help)
 $EXEC_NAME (-V|--version)
EOF
}


readonly VERSION=7

# TODO review possible error codes
set -o errexit -o nounset -o pipefail

readonly DEFAULT_PORT=1247
# TODO review possible error codes
readonly EXEC_NAME="$(basename "$(realpath --canonicalize-missing "$0")")"

# exit and return statuses
readonly OK=0
readonly NO_CONNECT=2
readonly ERROR=3


main() {
	declare -A argMap=(
		[help]=''
		[ies]=''
		[port]="$DEFAULT_PORT"
		[service]="$EXEC_NAME"
		[verbose]=''
		[version]=''
		[zone]='' )

	if ! map_args argMap "$@"; then
		print_usage >&2
		return $ERROR
	fi

	if [[ -n "${argMap[help]}" ]]; then
		help
		return $OK
	fi

  if [[ -n "${argMap[version]}" ]]; then
		print_version
		return $OK
	fi

	if [[ -z "${argMap[ies]}" ]]; then
		printf 'IES required\n' >&2
		print_usage >&2
		return $ERROR
	fi

	# TODO ensure only 0, 2, and 3 are returned
	ping \
		"${argMap[ies]}" "${argMap[port]}" "${argMap[service]}" "${argMap[zone]}" "${argMap[verbose]}"
}


# TODO describe mapVar
# TODO verify return codes are correct
# resolves the command line arguments
# Arguments:
#  The first argument is the name of the associative array where the resolved
#  arguments will be store. The remaining arguments hold the raw command line
#  arguments to resolve.
# Output:
#  Any issues with the command line arguments will be written to stderr.
# Return:
#  It returns the following codes.
#   0  on success
#   3  if the command line arguments don't make sense
#   4  if an internal error occured
map_args() {
	local mapVar="$1"
	shift

	local opts
	if ! opts="$(format_opts "$@")"; then
		return $ERROR
	fi

	eval set -- "$opts"

	while true; do
		case "$1" in
			-h|--help)
				eval "$mapVar""[help]=help"
				shift
				;;
			-P|--port)
				eval "$mapVar""[port]='$2'"
				shift 2
				;;
			-S|--service)
				eval "$mapVar""[service]='$2'"
				shift 2
				;;
			-v|--verbose)
				eval "$mapVar""[verbose]=verbose"
				shift
				;;
			-V|--version)
				eval "$mapVar""[version]=version"
				shift
				;;
			-Z|--zone)
				eval "$mapVar""[zone]='$2'"
				shift 2
				;;
			--)
				shift
				break
				;;
		esac
	done

	if [[ "$#" -ge 1 ]]; then
		eval "$mapVar""[ies]='$1'"
	fi
}


# TODO inline this function
# formats the command line options using `getopt`
# Arguments:
#  the raw command line arguments
# Output:
#  It writes the command line arguments as generated by `getopt` to stdout. Any
#  errors are written to stderr.
# Return:
#  It returns the following codes.
#   0  on success
#   3  if the command line options don't make sense
#   4  if an internal error occured
format_opts() {
	set +o errexit
	getopt \
		--name "$EXEC_NAME" \
		--longoptions help,port:,service:,verbose,version,zone: \
		--options hP:S:VvZ: \
		-- "$@"
	local rc=$?
	set -o errexit

	if (( rc == 0 )); then
		return $OK
	elif (( rc == 1 )); then
		return $ERROR
	else
		return $ERROR
	fi
}


# displays the program version in the format required of Nagios plugins
# Output:
#  the program version
# Return:
#  0 on success or 3 if an internal error occurred
print_version() {
	if ! printf '%s v%s\n' "$EXEC_NAME" "$VERSION"; then
		return $ERROR
	fi
}


ping() {
	local ies="$1"
	local port="$2"
	local service="$3"
	local zone="$4"
	local verbose="$5"

	local startTime
	startTime="$(date +'%s.%N')"

	# TODO review possible return codes for exec
	if ! exec 3<>/dev/tcp/"$ies"/"$port"; then
		printf 'down\n'
		return $NO_CONNECT
	fi

	local connMsgBody
	connMsgBody="$(mk_startup_pack "$service" "$zone")"

	if mk_req RODS_CONNECT "$connMsgBody" >&3; then
		local respMsg
		if respMsg="$(parse_resp <&3)"; then
			local stopTime
			# TODO review possible errors
			stopTime="$(date +'%s.%N')"

			mk_req RODS_DISCONNECT >&3
			close_conn

			if [[ -z "$verbose" ]]; then
				local dt
				# TODO review possible errors
				dt="$(awk --assign START="$startTime" --assign STOP="$stopTime" \
					'BEGIN { print (STOP - START) }')"

				printf 'up|time=%ss\n' "$dt"
			else
				printf '%s\n' "$respMsg"
			fi

			return $OK
		fi
	fi

	close_conn
	printf 'not iRODS\n'
	return $ERROR
}

# TODO swallow errors
close_conn() {
	exec 3<&-
	exec 3>&-
}


mk_req() {
	local msgType="$1"

	local msg=
	if [[ $# -ge 2 ]]; then
		msg="$2"
	fi

	local header
	header="$(mk_header "$msgType" ${#msg})"

	encode_header_len ${#header}
	printf '%s%s' "$header" "$msg"
}


parse_resp() {
	local headerLen
	headerLen="$(decode_header_len)"

	local header
	# TODO learn about errors
	read -r -d '' -n "$headerLen" header

	if ! [[ "$header" =~ ^\<MsgHeader_PI\>.*\<type\>RODS_VERSION\</type\>.*\<msgLen\>[0-9]+\< ]]; then
		return $ERROR
	fi

	local msgLen="${header#*<msgLen>}"
	msgLen="${msgLen%%<*}"

	local msg
	read -r -d '' -n "$msgLen" msg
	printf '%s' "$msg"
}


mk_header() {
	local type="$1"
	local msgLen="$2"

	cat <<EOX
<MsgHeader_PI>
	<type>$type</type>
	<msgLen>$msgLen</msgLen>
	<errorLen>0</errorLen>
	<bsLen>0</bsLen>
</MsgHeader_PI>
EOX
}


mk_startup_pack() {
	local clientUser="$1"
	local rcatZone="$2"

	cat <<EOX
<StartupPack_PI>
	<connectCnt>0</connectCnt>
	<proxyUser>$EXEC_NAME</proxyUser>
	<proxyRcatZone>$rcatZone</proxyRcatZone>
	<clientUser>$clientUser</clientUser>
	<clientRcatZone>$rcatZone</clientRcatZone>
	<relVersion></relVersion>
	<apiVersion></apiVersion>
	<option>$EXEC_NAME</option>
</StartupPack_PI>
EOX
}


encode_header_len() {
	local len="$1"

	# TODO learn about possible errors
	printf '0: %.8x' "$len" | xxd -revert -g 0
}


# Decodes a serialized iRODS protocol packet header length
# Input:
#   the serialized length
# Output:
#   the decimal value to stdout.
decode_header_len() {
	local lenHex
	# TODO learn about possible errors
	lenHex="$(od --address-radix n --format x1 --read-bytes 4 | tr --delete ' ')"

	printf '%d' $((16#$lenHex))
}


main "$@"
