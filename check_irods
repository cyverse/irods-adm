#!/bin/bash

print_usage() {
	cat <<EOF
Usage:
 $EXEC_NAME [-v|--verbose][(-P|--port) PORT][(-S|--service) SERVICE]
  [(-Z|--zone) ZONE] IES
 $EXEC_NAME (-h|--help)
 $EXEC_NAME (-?|--usage)
 $EXEC_NAME (-V|--version)
EOF
}


print_description() {
	cat <<EOF
Nagios plugin that checks to see is if an iRODS server is online. It supports
Nagios version 2 or later and iRODS version 4 or later.

Parameters:
 HOST  the FQDN or IP address of the server hosting the service

Options:
 -h, --help             show help and exit
 -P, --port PORT        the TCP port the iRODS server listens to on HOST
                        (default 1247)
 -S, --service SERVICE  the name of the service checking iRODS, identified as
                        client user to iRODS
 -?, --usage            show a usage message and exit
 -v, --verbose          show additional information, a repeat of this flag will
                        show the response from the server
 -V, --version          show version and exit
 -Z, --zone ZONE        the name of the zone to tell iRODS this program and
                        SERVICE belong to.

Output:
 Unless otherwise indicated, it writes the status of the iRODS service on HOST
 to stdout in a form interpretable by nagios. When the plugin successfully
 connects to iRODS, it provides the amount of time it took to connect as a
 performance datum in the form "time=<duration>s" where <duration> is the amount
 of time in seconds.

Side Effects:
 The rodsLog will show a connection from the host where this is run with the
 proxy user set to "$EXEC_NAME". If SERVICE is specified, the client user will
 be set to SERVICE instead. If ZONE is specificed, the zone for both users will
 be ZONE.

 If \`ips\` happens to be called while this is program is connected to iRODS,
 \`ips\` will show this program's connection as comming from "$EXEC_NAME".

Exit Status:
 0  connected to iRODS
 2  failed to connect to iRODS
 3  an error occurred or connected to something other than iRODS

Â© 2019, 2021 The Arizona Board of Regents on behalf of The University of
Arizona. For license information, see https://cyverse.org/license.
EOF
}


set -o errexit -o nounset -o pipefail

readonly VERSION=8

readonly DEFAULT_EXEC_NAME=check_irods
readonly DEFAULT_PORT=1247

# exit and return statuses
declare -i -r OK=0
#declare -i -r WARNING=1  # Not used yet
declare -i -r CRITICAL=2
declare -r -r UNKNOWN=3

# verbosity
declare -i -r TERSE=0
#declare -i -r VERBOSE=1   # Not used yet
declare -i -r CFG_DEBUG=2

declare EXEC_NAME


main() {
	if ! EXEC_NAME="$(basename "$(realpath --canonicalize-missing "$0")")"; then
		printf 'cannot determine executable name, using %s\n' "$DEFAULT_EXEC_NAME" >&2 || true
		EXEC_NAME="$DEFAULT_EXEC_NAME"
	fi
	readonly EXEC_NAME

	declare -A argMap=(
		[help]=''
		[ies]=''
		[port]="$DEFAULT_PORT"
		[service]="$EXEC_NAME"
		[usage]=''
		[verbose]="$TERSE"
		[version]=''
		[zone]='' )

	if ! map_args argMap "$@"; then
		print_usage >&2 || true
		return $UNKNOWN
	fi

	if [[ -n "${argMap[help]}" ]]; then
		if ! print_help; then
			return $UNKNOWN
		fi

		return $OK
	elif [[ -n "${argMap[usage]}" ]]; then
		if ! print_usage; then
			return $UNKNOWN
		fi

		return $OK
	elif [[ -n "${argMap[version]}" ]]; then
		if ! print_version; then
			return $UNKNOWN
		fi

		return $OK
	else
		if [[ -z "${argMap[ies]}" ]]; then
			printf 'IES required\n' >&2 || true
			print_usage >&2 || true
			return $UNKNOWN
		fi

		ping \
			"${argMap[ies]}" "${argMap[port]}" "${argMap[service]}" "${argMap[zone]}" "${argMap[verbose]}"
	fi
}


# It resolves the command line arguments, storing them in an associative array
# using the long option names as the keys.
# Arguments:
#  The first argument is the name of the associative array where the resolved.
#  The remaining arguments hold the raw command line arguments to resolve.
map_args() {
	local mapVar="$1"
	shift

	local opts
	if ! opts="$(format_opts "$@")"; then
		return 1
	fi

	eval set -- "$opts"

	while true; do
		case "$1" in
			-h|--help)
				eval "$mapVar""[help]=help"
				shift
				;;
			-P|--port)
				eval "$mapVar""[port]='$2'"
				shift 2
				;;
			-S|--service)
				eval "$mapVar""[service]='$2'"
				shift 2
				;;
			-\?|--usage)
				eval "$mapVar""[usage]=usage"
				shift
				;;
			-v|--verbose)
				eval "$mapVar"'[verbose]=$(( ${'"$mapVar"'[verbose]} + 1 ))'
				shift
				;;
			-V|--version)
				eval "$mapVar""[version]=version"
				shift
				;;
			-Z|--zone)
				eval "$mapVar""[zone]='$2'"
				shift 2
				;;
			--)
				shift
				break
				;;
		esac
	done

	if [[ "$#" -ge 1 ]]; then
		eval "$mapVar""[ies]='$1'"
	fi
}


# formats the command line options like `getopt`
# Arguments:
#  the raw command line arguments
# Output:
#  It writes the command line arguments as generated by `getopt` to stdout.
format_opts() {
	# getopt doesn't support "?" as a short option, so replace all instances of -?
	# with --usage
	local transArgs=()

	local ai
	for (( ai=1; ai<=$#; ai++ )); do
		local arg="${!ai}"

		if [[ "$arg" =~ ^-[^-] ]]; then
			local shopts=''

			local ci
			for (( ci=1; ci<${#arg}; ci++ )); do
				local c="${arg:$ci:1}"

				if [[ "$c" == '?' ]]; then
					if [[ -n "$shopts" ]]; then
						transArgs+=( -"$shopts" )
						shopts=''
					fi

					transArgs+=( --usage )
		  	else
					shopts+="$c"
				fi
			done

			if [[ -n "$shopts" ]]; then
				transArgs+=( -"$shopts" )
			fi
		else
			transArgs+=( "$arg" )
		fi
	done

	getopt \
		--name "$EXEC_NAME" \
		--longoptions help,port:,service:,usage,verbose,version,zone: \
		--options 'hP:S:VvZ:' \
		-- "${transArgs[@]}"
}


# displays detailed help
# Output:
#  the help text formatted to fit on an 80 character wide terminal
print_help() {
	print_version
	printf '\n'
	print_usage
	printf '\n'
	print_description
}


# displays the program version in the format required of Nagios plugins
print_version() {
	printf '%s v%s\n' "$EXEC_NAME" "$VERSION"
}


# TODO add support for verbosity=1 See
#  https://nagios-plugins.org/doc/guidelines.html#VERBOSELEVELS
# TODO review possible internal return statuses and ensure correct return status and message
ping() {
	local ies="$1"
	local port="$2"
	local service="$3"
	local zone="$4"
	local verbosity="$5"

	local startTime
	startTime="$(date +'%s.%N')"

	if ! exec 3<>/dev/tcp/"$ies"/"$port"; then
		printf 'CRITICAL: down\n'
		return $CRITICAL
	fi

	local connMsgBody
	connMsgBody="$(mk_startup_pack "$service" "$zone")"

	if mk_req RODS_CONNECT "$connMsgBody" >&3; then
		local respMsg
		if respMsg="$(parse_resp <&3)"; then
			local stopTime
			stopTime="$(date +'%s.%N')"

			mk_req RODS_DISCONNECT >&3
			close_conn

			local dt
			dt="$(awk --assign START="$startTime" --assign STOP="$stopTime" \
				'BEGIN { print (STOP - START) }')"

			printf 'OK: up | time=%ss\n' "$dt"

			if (( verbosity >= CFG_DEBUG )); then
				printf '%s\n' "$respMsg"
			fi

			return $OK
		fi
	fi

	close_conn
	printf 'CRITICAL: not iRODS\n'
	return $CRITICAL
}


# TODO document
close_conn() {
	exec 3<&- || true
	exec 3>&- || true
}


# TODO document
mk_req() {
	local msgType="$1"

	local msg=
	if [[ $# -ge 2 ]]; then
		msg="$2"
	fi

	local header
	header="$(mk_header "$msgType" ${#msg})"

	encode_header_len ${#header}
	printf '%s%s' "$header" "$msg"
}


# TODO document
parse_resp() {
	local headerLen
	headerLen="$(decode_header_len)"

	local header
	# TODO learn about errors
	read -r -d '' -n "$headerLen" header

	if ! [[ "$header" =~ ^\<MsgHeader_PI\>.*\<type\>RODS_VERSION\</type\>.*\<msgLen\>[0-9]+\< ]]; then
		return $UNKNOWN
	fi

	local msgLen="${header#*<msgLen>}"
	msgLen="${msgLen%%<*}"

	local msg
	read -r -d '' -n "$msgLen" msg
	printf '%s' "$msg"
}


# TODO document
mk_header() {
	local type="$1"
	local msgLen="$2"

	cat <<EOX
<MsgHeader_PI>
	<type>$type</type>
	<msgLen>$msgLen</msgLen>
	<errorLen>0</errorLen>
	<bsLen>0</bsLen>
</MsgHeader_PI>
EOX
}


# TODO document
mk_startup_pack() {
	local clientUser="$1"
	local rcatZone="$2"

	cat <<EOX
<StartupPack_PI>
	<connectCnt>0</connectCnt>
	<proxyUser>$EXEC_NAME</proxyUser>
	<proxyRcatZone>$rcatZone</proxyRcatZone>
	<clientUser>$clientUser</clientUser>
	<clientRcatZone>$rcatZone</clientRcatZone>
	<relVersion></relVersion>
	<apiVersion></apiVersion>
	<option>$EXEC_NAME</option>
</StartupPack_PI>
EOX
}


# TODO document
encode_header_len() {
	local len="$1"

	# TODO learn about possible errors
	printf '0: %.8x' "$len" | xxd -revert -g 0
}


# Decodes a serialized iRODS protocol packet header length
# Input:
#   the serialized length
# Output:
#   the decimal value to stdout.
decode_header_len() {
	local lenHex
	# TODO learn about possible errors
	lenHex="$(od --address-radix n --format x1 --read-bytes 4 | tr --delete ' ')"

	printf '%d' $((16#$lenHex))
}


main "$@"
