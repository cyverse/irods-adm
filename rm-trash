#!/bin/bash

show_help()
{
  cat <<EOF

$ExecName version $Version

Usage:
 $ExecName [options]

This script deletes the trash older than one month. It deletes the oldest trash
first. It writes a complete report of everything deleted to standard output by
default with all error messages be written to both standard error. If the output
is directed to FILE, error messages will still be written to standard error in
addition to FILE. In any case, each message written is formatted in syslog
style.

Options:
 -h, --help      show help and exit
 -L, --log FILE  write all output to FILE
 -v, --version   show version and exit
EOF
}


set -o nounset -o pipefail
trap 'exit 130' INT

readonly Version=2
readonly ExecAbsPath=$(readlink --canonicalize "$0")
readonly ExecName=$(basename "$ExecAbsPath")

readonly Concurrency=4


main()
{
  declare -A optMap=(
    [help]=''
    [version]=''
    [log]=''
  )

  if ! map_opts optMap "$@"
  then
    show_help >&2
    return 1
  fi

  if [[ -n "${optMap[help]}" ]]
  then
    show_help
    return 0
  fi

  if [[ -n "${optMap[version]}" ]]
  then
    printf '%s\n' "$Version"
    return 0
  fi

  if [[ -n "${optMap[log]}" ]]
  then
    if ! redirect_stdout "${optMap[log]}"
    then
      return 1
    fi
  fi

  local trashTmpFiles
  if ! trashTmpFiles=$(mktemp)
  then
    # shellcheck disable=SC2182
    printf 'Failed to create database for temporary files\n' >(disp_err)
    return 1
  fi

  # shellcheck disable=SC2064
  trap "rm_temps '$trashTmpFiles' 2> >(disp_err) > >(disp_out)" EXIT

  rm_trash "$trashTmpFiles" 2> >(disp_err) > >(disp_out)
}


map_opts()
{
  local mapVar="$1"
  shift

  local opts
  if ! opts=$(getopt --longoptions help,log:,version --options hL:v --name "$ExecName" -- "$@")
  then
    return 1
  fi

  eval set -- "$opts"

  while true
  do
    case "$1" in
      -h|--help)
        eval "$mapVar[help]=help"
        shift
        ;;
      -L|--log)
        eval "$mapVar[log]='$2'"
        shift 2
        ;;
      -v|--version)
        eval "$mapVar[version]=version"
        shift
        ;;
      --)
        shift
        break
        ;;
      *)
        return 1
        ;;
    esac
  done
}


redirect_stdout()
{
  local logFile="$1"

  exec 1>&-

  if ! exec 1>"$logFile"
  then
    exec 1>/dev/stdout
    printf 'Failed to open %s for writing\n' "$logFile" >&2
    return 1
  fi
}


rm_temps()
{
  local trashTempFiles="$1"

  xargs --no-run-if-empty rm --force < "$trashTempFiles"
  rm --force "$trashTempFiles"
}


disp_err()
{
  while IFS= read -r err
  do
    fmt_msg ERROR "$err"
  done | route_err
}


disp_out()
{
  while IFS= read -r msg
  do
    fmt_msg INFO "$msg"
  done
}


fmt_msg()
{
  local type="$1"
  local body="$2"

  printf '%s %s: %s\n' "$(date --iso-8601=seconds)" "$type" "$body"
}


route_err()
{
  if [[ -t 1 ]]
  then
    cat >&2
  else
    tee /dev/stderr
  fi
}


rm_trash()
{
  local trashTempFiles="$1"

  local zone
  zone=$(ienv | sed --quiet 's/NOTICE: irods_zone_name - //p')

  local upperBound
  upperBound=$(date --date "$(date --iso-8601 --date '1 month ago')" '+%s')

  local trashList
  trashList=$(mk_temp "$trashTempFiles")

  # Build the list of data objects to delete, sorted by age
  quest '%s %s/%s' \
      "select max(DATA_MODIFY_TIME), COLL_NAME, DATA_NAME
       where COLL_NAME like '/$zone/trash/%'" \
    | sort --numeric --key 1,1 \
    | truncate_by_time "$upperBound" \
    | cut --delimiter ' ' --fields 2- \
    > "$trashList"

  local delTot
  delTot=$(wc --lines < "$trashList")
  printf '%d data objects will be deleted\n' "$delTot"

  parallel --line-buffer --no-notice --no-run-if-empty \
      --delimiter '\n' --max-args 100 --max-procs "$Concurrency" \
      RM_DATA_BATCH \
    < "$trashList"

  # Remove the empty trash collections
  quest '%s' \
      "select order(COLL_NAME)
       where COLL_PARENT_NAME = '/$zone/trash' || = '/$zone/trash/home'
         and COLL_NAME != '/$zone/trash/home'" \
    > "$trashList"

  delTot=$(wc --lines < "$trashList")
  printf '%d base collections will be pruned\n' "$delTot"

  local parent
  while read -r parent
  do
    prune_children "$trashTempFiles" "$parent"
    printf 'Pruned base collection %s\n' "$parent"
  done < "$trashList"

  rm --force "$trashList"
}


mk_temp()
{
  local trashTempFiles="$1"

  mktemp | tee --append "$trashTempFiles"
}


prune_children()
{
  local trashTempFiles="$1"
  local parent="$2"

  local childList
  childList=$(mk_temp "$trashTempFiles")

  quest '%s' "select COLL_NAME where COLL_PARENT_NAME = '$parent'" > "$childList"

  local collection
  while read -r collection
  do
    prune_collection "$trashTempFiles" "$collection"
  done < "$childList"

  rm --force "$childList"
}


prune_collection()
{
  local trashTempFiles="$1"
  local collection="$2"

  local collDoTot
  collDoTot=$(quest '%s' "select count(DATA_ID) where COLL_NAME = '$collection'")

  if [[ "$collDoTot" -eq 0 ]]
  then
    collDoTot=$(quest '%s' "select count(DATA_ID) where COLL_NAME like '$collection/%'")
  fi

  if [[ "$collDoTot" -eq 0 ]]
  then
    if irm -f -r -v "$collection"
    then
      printf 'Deleted collection %s\n' "$collection"
    fi
  else
    prune_children "$trashTempFiles" "$collection"
    printf 'Pruned collection %s\n' "$collection"
  fi
}


quest()
{
  local fmt="$1"
  local query="$2"

  iquest --no-page "$fmt" "$query" \
    | sed '/^CAT_NO_ROWS_FOUND: Nothing was found matching your query$/d'
}


truncate_by_time()
{
  local upperBound="$1"

  local dataObj modifyTs
  while read -r modifyTs dataObj
  do
    if [[ "${modifyTs#0}" -ge "$upperBound" ]]
    then
      break
    fi

    printf '%s %s\n' "$modifyTs" "$dataObj"
  done
}


RM_DATA_BATCH()
{
  stdbuf --error L --output L irm -f -v "$@" | MK_RM_MSGS "$@"
}
export -f RM_DATA_BATCH


MK_RM_MSGS()
{
  local paths=("$@")
  local idx=0

  local line
  while IFS= read -r line
  do
    local nameBeg
    nameBeg=$(expr "$line" : '^   \(.*[^ ]\)  *[0-9][0-9]*\.[0-9][0-9][0-9] sec$')

    local dur
    dur=$(expr "$line" : '.*\([0-9][0-9]*\.[0-9][0-9][0-9]\) sec$')
    while [[ "$idx" -lt "${#paths[@]}" ]]
    do
      local path="${paths[$((idx++))]}"

      local name
      name=$(basename "$path")

      if [[ "$name" =~ $nameBeg ]]
      then
        printf 'took %s to delete data object %s\n' "$dur" "$path"
        break
      fi
    done
  done
}
export -f MK_RM_MSGS


main "$@"
