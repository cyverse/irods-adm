#!/bin/bash
# XXX pidof that is installed from sysvinit-tools-2.88 doesn't detect scripts
#     launched using env. After switching our admin servers to Ubuntu, we
#     can revert this workaround
##!/usr/bin/env bash
# XXX ^^^


show_help() {
	cat <<EOF

$EXEC_NAME version $VERSION

Usage:
 $EXEC_NAME -h|--help
 $EXEC_NAME -v|--version
 $EXEC_NAME [-d|--debug | (-D|--db-name) DB-NAME | (-U|--db-user) DB-USER 
    | (-H|--dbms-host) DBMS-HOST | (-P|--dbms-port) DBMS-PORT 
	 | (-I|--ignore) IGNORE] | (-S|--STAGE) STAGE-DIR

This program fixes the following three common problems that happen when an 
upload fails.

1. The rodsadmin group isn't given own permission on a new collection or data
   object.
2. A new collection or data object doesn't receive a UUID.
3. A checksum isn't computed for a new or modified data object replica.

It generates two reports: one for collections and one for data objects. Each 
report lists all collections or data objects, respectively, that had one or more 
of the problems. For each problem, the report indicates if the script was able 
to fix the problem. If the program wasn't able to, the error encountered while 
attempting the fix will be included at the bottom of the relevant report.

Options:
 -D, --db-name DB-NAME      the name of the catalog database
 -U, --db-user DB-USER      the account used to authorized the connection to the
                            DB
 -H, --dbms-host DBMS-HOST  the domain name or IP address of the server hosting
                            the PostgreSQL DBMS containing the DB
 -P, --dbms-port DBMS-PORT  the TCP port the DBMS listens on
 -d, --debug                will cause the program to display messages 
                            describing what it is doing
 -I, --ignore IGNORE        a path to a collection whose contents should not be
                            inspected for problems
 -S, --stage STAGE-DIR      the name of a directory where used for staging the
                            reports before writing them to stdout, default is 
                            TMPDIR
 -h, --help                 show help and exit
 -v, --version              show version and exit

Environment Variables:
 PGDATABASE  provides the default value for the catalog DB name, default is 
             "ICAT"
 PGHOST      provides the default value for the DBMS host, default is 
             "localhost"
 PGPORT      provides the default value for the TCP port the DBMS listens on, 
             default is 5432
 PGUSER      provides the default value for the account used to authorize the 
             connection, default is the user executing this program.
 TMPDIR      the absolute path to the temporary directory, default is /tmp.
 
Â© 2022, The Arizona Board of Regents on behalf of The University of Arizona. For
license information, see https://cyverse.org/license.
EOF
}


readonly VERSION=7

set -o errexit -o nounset -o pipefail

export PGDATABASE PGHOST PGPORT PGUSER TMPDIR

readonly COLL_TABLE_TITLE='Collection Repair Attempts'
readonly DATA_TABLE_TITLE='Data Object Repair Attempts'
readonly DEFAULT_DB=ICAT
readonly DEFAULT_TMPDIR=/tmp
readonly MAX_LOG_SIZE=12582912  # 12 MiB

EXEC_NAME="$(basename "$(realpath --canonicalize-missing "$0")")"
readonly EXEC_NAME

declare DEBUG

declare -i CollCnt=0
declare -i ObjCnt=0

declare -a TempFiles


main() {
	declare -A argMap=(
		[help]=''
		[ignore]=''
		[version]='' )

	if ! map_args argMap "$@"; then
		show_help >&2
		return 1
	fi

	if [[ -n "${argMap[help]}" ]]; then
		show_help
	elif [[ -n "${argMap[version]}" ]]; then
		printf '%s\n' "$VERSION"
	else
		fix "${argMap[ignore]}"
	fi
}


# It resolves the command line arguments, storing them in an associative array
# using the long option names as the keys.
# Arguments:
#  The first argument is the name of the associative array where the resolved.
#  The remaining arguments hold the raw command line arguments to resolve.
# Side Effects:
#  DEBUG, PGDATABASE, PGHOST, PGPORT, PGUSER, and TMPDIR are set.
map_args() {
	local mapVar="$1"
	shift

	local opts
	if ! opts="$(format_opts "$@")"; then
		return 1
	fi

	eval set -- "$opts"

	local help ignore version
	while true; do
		case "$1" in
			-D|--db-name)
				PGDATABASE="$2"
				shift 2
				;;
			-U|--db-user)
				PGUSER="$2"
				shift 2
				;;
			-H|--dbms-host)
				PGHOST="$2"
				shift 2
				;;
			-P|--dbms-port)
				PGPORT="$2"
				shift 2
				;;
			-d|--debug)
				DEBUG=debug
				shift
				;;
			-h|--help)
				eval "$mapVar""[help]=help"
				shift
				;;
			-I|--ignore)
				eval "$mapVar""[ignore]='$2'"
				shift 2
				;;
			-S|--stage)
				TMPDIR="$2"
				shift 2
				;;
			-v|--version)
				eval "$mapVar""[version]=version"
				shift
				;;
			--)
 				shift
 				break
 				;;
		esac
	done

	readonly DEBUG

	if [[ -z "${PGDATABASE-}" ]]; then
		PGDATABASE="$DEFAULT_DB"
	fi

	if [[ -z "${TMPDIR-}" ]]; then
		TMPDIR="$DEFAULT_TMPDIR"
	fi
}


# formats the command-line options using getopt
# Arguments:
#  It accepts the raw commandline arguments
# Output:
#  the arguments formatted by getopt
format_opts() {
	getopt \
		--name "$EXEC_NAME" \
		--longoptions db-name:,db-user:,dbms-host:,dbms-port:,debug,help,ignore:,stage:,version \
		--options D:dH:hI:P:S:U:v \
		-- "$@"
}


# performs any needed fixes and genertes the report
# Arguments:
#  It accepts the path to a collection whose contents should not be fixed 
# Output:
#  the reports
fix() {
	local ignoreColl="$1"

	if existing_instance; then
		printf '%s already running\n' "$EXEC_NAME" 1>&2
		return 1
	fi

	local reportTime
	reportTime="$(date --iso-8601=seconds)"

	trap rm_temp_files EXIT

	TempFiles+=("$(mktemp)")
	local problems="${TempFiles[-1]}"

	local zone
	if ! zone="$(iquest '%s' "select ZONE_NAME where ZONE_TYPE = 'local'")"; then
		printf 'Failed to determine local zone\n' >&2
		return 1
	fi

	display_problems "$zone" "$ignoreColl" | strip_noise > "$problems"

	trap 'if [[ "${FUNCNAME[0]-}" != main ]]; then return; fi' SIGINT SIGTERM

	TempFiles+=("$(mktemp)")
	local fixLog="${TempFiles[-1]}"

	TempFiles+=("$(mktemp)")
	local errorLog="${TempFiles[-1]}"

	fix_problems < "$problems" > "$fixLog" 2> "$errorLog" || true
	generate_report "$reportTime" "$fixLog" "$errorLog"
}


# uses PostgreSQL to display the problems in a human-readable format
# Arguments
#  zone - The iRODS zone being fixed
#  ignoreColl - A path to a collection that should not be fixed.
# Output:
#  It generates the following output:
#
# ```
#                   Collection Repair Attempts
#  Permission Issue | UUID Count | Owner | Create Time | Collection
# ------------------+------------+-------+-------------+------------
# <broken-coll>
# ...
# <broken-coll>
# (<#-broken-colls> collections)
#
#                                 Data Object Repair Attempts
#  Permission Issue | Missing Checksum | UUID Count | Owner | Replica | Create Time | Data Object                                                                               
# ------------------+------------------+------------+-------+---------+-------------+-------------
# <broken-obj>
# ...
# <broken-obj>
# (<#-broken-objs> data objects)
# ```
# 
# <broken-coll> has the following form:
#
# ```
# <perm-issue?> | <uuid-count> | <owner> | <create-time> | <path>
# ```
#
# <broken-obj> has the following form:
#
# ```
# <perm-issue?> | <missing-chksum?> | <uuid-count> | <owner> | <repl-num> | <create-time> | <path>
# ```
#
# The entries in a <broken-coll> or <broken-obj> line are as follows:
#
# * <perm-issue?> is either `t` for true or `f` for false
# * <missing-chksum?> is either `t` for true or `f` for false
# * <uuid-count> is a non-negative integer
# * <owner> has the form <username>#<zone> where <username> and <zone> are text
# * <repl-num> is a non-negative integer
# * <create-time> has the form `<date> <time>` where <date> has the form 
#   YYYY-MM-DD and <time> has the form HH:mm:ssZZZ where ZZZ is the local time 
#   zone offset from UTC.
# * <path> is the absolute path to the collection or data object
#
# <#-broken-colls> and <#-broken-objs> are the number of collections and data 
# objects, respectively, that need to be repaired.
display_problems() {
	local zone="$1"
	local ignoreColl="$2"

	psql <<EOF
$(inject_debug_stmt '\timing on')
$(inject_debug_newline)
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

$(inject_debug_msg creating owned_by_rodsadmin)
CREATE TEMPORARY TABLE owned_by_rodsadmin AS
SELECT a.object_id
FROM r_objt_access AS a JOIN r_user_main AS u ON u.user_id = a.user_id
WHERE u.user_name = 'rodsadmin'
	AND a.access_type_id = (
		SELECT token_id
		FROM r_tokn_main
		WHERE token_namespace = 'access_type' AND token_name = 'own' );
CREATE INDEX idx_owned_by_rodsadmin ON owned_by_rodsadmin (object_id);

$(inject_debug_msg creating coll_perm_probs)
CREATE TEMPORARY TABLE coll_perm_probs AS
SELECT coll_id
FROM r_coll_main AS c
WHERE NOT EXISTS (SELECT * FROM owned_by_rodsadmin AS o WHERE o.object_id = c.coll_id)
	AND c.coll_name LIKE '/$zone/%/%' 
	AND ($(inject_ignore_coll c.coll_name "$ignoreColl")) 
	AND c.coll_type != 'linkPoint';
CREATE INDEX idx_coll_perm_probs ON coll_perm_probs(coll_id);

$(inject_debug_msg creating data_perm_probs)
CREATE TEMPORARY TABLE data_perm_probs AS
SELECT DISTINCT data_id
FROM r_data_main AS d JOIN r_coll_main AS c ON c.coll_id = d.coll_id
WHERE c.coll_name LIKE '/$zone/%'
	AND ($(inject_ignore_coll c.coll_name "$ignoreColl")) 
	AND NOT EXISTS (SELECT * FROM owned_by_rodsadmin AS o WHERE o.object_id = d.data_id)
	AND d.data_is_dirty <= 1;
CREATE INDEX idx_data_perm_probs ON data_perm_probs(data_id);

$(inject_debug_msg creating uuid_attrs)
CREATE TEMPORARY TABLE uuid_attrs AS
SELECT o.object_id
FROM r_objt_metamap AS o JOIN r_meta_main AS m ON m.meta_id = o.meta_id
WHERE m.meta_attr_name = 'ipc_UUID';
CREATE INDEX idx_uuid_attrs ON uuid_attrs (object_id);

$(inject_debug_msg creating coll_uuid_probs)
CREATE TEMPORARY TABLE coll_uuid_probs (coll_id, uuid_count) AS
SELECT c.coll_id, COUNT(u.object_id)
FROM r_coll_main AS c LEFT JOIN uuid_attrs AS u ON u.object_id = c.coll_id
WHERE c.coll_name LIKE '/$zone/%' 
	AND ($(inject_ignore_coll c.coll_name "$ignoreColl")) 
	AND c.coll_type != 'linkPoint'
GROUP BY c.coll_id
HAVING COUNT(u.object_id) != 1;
CREATE INDEX idx_coll_uuid_probs ON coll_uuid_probs (coll_id);

$(inject_debug_msg creating data_uuid_probs)
CREATE TEMPORARY TABLE data_uuid_probs (data_id, uuid_count) AS
SELECT DISTINCT d.data_id, COUNT(u.object_id)
FROM r_data_main AS d LEFT JOIN uuid_attrs AS u ON u.object_id = d.data_id
WHERE d.data_is_dirty <= 1
	AND d.coll_id IN (
		SELECT coll_id 
		FROM r_coll_main
		WHERE coll_name LIKE '/$zone/%' AND ($(inject_ignore_coll coll_name "$ignoreColl")) )
GROUP BY d.data_id, d.data_repl_num
	-- data_repl_num prevents counting uuids for multiple repls in a single count
HAVING COUNT(u.object_id) != 1;
CREATE INDEX idx_data_uuid_probs ON data_uuid_probs(data_id);

$(inject_debug_msg creating data_checksum_probs)
CREATE TEMPORARY TABLE data_chksum_probs AS
SELECT DISTINCT data_id
FROM r_data_main 
WHERE data_is_dirty <= 1 
	AND (data_checksum IS NULL OR data_checksum = '')
	AND coll_id IN (
		SELECT coll_id 
		FROM r_coll_main
		WHERE coll_name LIKE '/$zone/%' AND ($(inject_ignore_coll coll_name "$ignoreColl")) );

$(inject_debug_newline)
$(inject_set_title "$COLL_TABLE_TITLE")
SELECT
	coll_id IN (SELECT * FROM coll_perm_probs) AS "Permission Issue",
	COALESCE((SELECT cu.uuid_count FROM coll_uuid_probs AS cu WHERE cu.coll_id = c.coll_id), 1)
		AS "UUID Count",
	coll_owner_name || '#' || coll_owner_zone AS "Owner",
	TO_TIMESTAMP(CAST(create_ts AS INTEGER)) AS "Create Time",
	REPLACE(REPLACE(coll_name, E'\\\\', E'\\\\\\\\'), E'\\n', E'\\\\n')  AS "Collection"
FROM r_coll_main AS c
WHERE coll_id IN (SELECT * FROM coll_perm_probs UNION SELECT coll_id FROM coll_uuid_probs)
ORDER BY create_ts;

\echo ''
$(inject_set_title "$DATA_TABLE_TITLE")
SELECT
	d.data_id IN (SELECT * FROM data_perm_probs) AS "Permission Issue",
	d.data_checksum IS NULL OR d.data_checksum = '' AS "Missing Checksum",
	COALESCE((SELECT du.uuid_count FROM data_uuid_probs AS du WHERE du.data_id = d.data_id), 1)
		AS "UUID Count",
	d.data_owner_name || '#' || d.data_owner_zone AS "Owner",
	d.data_repl_num AS "Replica",
	TO_TIMESTAMP(CAST(d.create_ts AS INTEGER)) AS "Create Time",
	REPLACE(REPLACE(c.coll_name || '/' || d.data_name, E'\\\\', E'\\\\\\\\'), E'\\n', E'\\\\n')
		AS "Data Object"
FROM r_coll_main AS c JOIN r_data_main AS d ON d.coll_id = c.coll_id
WHERE d.data_id IN (
	SELECT * FROM data_perm_probs
	UNION SELECT data_id FROM data_uuid_probs
	UNION SELECT data_id FROM data_chksum_probs )
ORDER BY d.create_ts;

$(inject_debug_newline)
ROLLBACK;
EOF
}

inject_ignore_coll() {
	local field="$1"
	local coll="$2"

	if [[ -n "$coll" ]]; then
		printf $'%s NOT SIMILAR TO \'%s(/%%)?\'' "$field" "$coll"
	else
		printf 'TRUE'
	fi
}


inject_debug_msg() {
	local msg="$*"

	inject_debug_newline
	inject_debug_stmt "\\echo '$msg'"
}


inject_debug_newline() {
	inject_debug_stmt "\\echo ''"
}


inject_debug_stmt() {
	local stmt="$*"

	if [[ -n "${DEBUG-}" ]]; then
		printf '%s\n' "$stmt"
	fi
}


inject_ignore_coll() {
	local field="$1"
	local coll="$2"

	if [[ -n "$coll" ]]; then
		printf $'%s NOT SIMILAR TO \'%s(/%%)?\'' "$field" "$coll"
	else
		printf 'TRUE'
	fi
}


inject_set_title() {
	local title="$*"

	inject_debug_quiet on
	printf $'\pset title \'%s\'\n' "$title"
	inject_debug_quiet off
}


inject_debug_quiet() {
	local state="$1"

	printf $'\\set QUIET %s\n' "$state"
}


existing_instance() {
	local pidofExec
	pidofExec="$(command -v pidof)"
	"${pidofExec:-/sbin/pidof}" -x -o%PPID "$EXEC_NAME" > /dev/null
}


fix_problems() {
	while IFS= read -r; do
		printf '%s\n' "$REPLY"

		case "$REPLY" in
			*"$COLL_TABLE_TITLE")
				fix_collection_problems
				;;
			*"$DATA_TABLE_TITLE")
				fix_object_problems
				;;
			*)
				;;
		esac
	done
}


fix_collection_problems() {
	pass_hdr_thru

	trap 'complete_fix_coll "${FUNCNAME[0]-}"; rm_temp_files' EXIT
	trap 'complete_fix_coll "${FUNCNAME[0]-}"' RETURN

	local permIssue
	local uuidCnt
	local owner
	local createTime
	local collField
	while IFS='|' read -r permIssue uuidCnt owner createTime collField; do
		if [ -z "$collField" ]; then
			break
		fi

		local escColl
		escColl="$(trim "$collField")"

		local coll
		coll="$(unescape "$escColl")"

		if ! permIssue="$(process_perm_issue "$permIssue" "$coll")"; then
			continue
		fi

		if ! uuidCnt="$(process_uuid_issue "$uuidCnt" coll "$coll")"; then
			continue
		fi

		printf '%s|%s|%s|%s|%s\n' "$permIssue" "$uuidCnt" "$owner" "$createTime" "$collField"
		: $(( CollCnt++ ))
	done
}


complete_fix_coll() {
	local funcName="$1"

	if [[ "$funcName" == fix_collection_problems ]]; then 
		printf '(%d collections)' "$CollCnt"
	fi
}


fix_object_problems() {
	pass_hdr_thru

	trap 'complete_fix_objs "${FUNCNAME[0]-}"; rm_temp_files' EXIT
	trap 'complete_fix_objs "${FUNCNAME[0]-}"' RETURN

	local permIssue missingChksum uuidCnt owner replField createTime objField
	while IFS='|' read -r permIssue missingChksum uuidCnt owner replField createTime objField; do
		if [ -z "$objField" ]; then
			break
		fi

		local escObj
		escObj="$(trim "$objField")"

		local obj
		obj="$(unescape "$escObj")"

		local repl
		repl="$(trim "$replField")"

		if ! permIssue="$(process_perm_issue "$permIssue" "$obj")"; then
			continue
		fi

		if ! missingChksum="$(process_chksum_issue "$missingChksum" "$repl" "$obj")"; then
			continue
		fi

		if ! uuidCnt="$(process_uuid_issue "$uuidCnt" obj "$obj")"; then
			continue
		fi

		printf '%s|%s|%s|%s|%s|%s|%s\n' \
			"$permIssue" "$missingChksum" "$uuidCnt" "$owner" "$replField" "$createTime" "$objField"

		: $(( ObjCnt++ ))	
	done
}


complete_fix_objs() {
	local funcName="$1"

	if [[ "$funcName" == fix_object_problems ]]; then 
		printf '(%d data objects)' "$ObjCnt"
	fi
}


pass_hdr_thru() {
	while read -r; do
		printf '%s\n' "$REPLY"

		if [[ "$REPLY" =~ ^- ]]; then
			break
		fi
	done
}


trim() {
	local str="$*"
	str="${str#"${str%%[![:space:]]*}"}"
	str="${str%"${str##*[![:space:]]}"}"
	printf '%s' "$str"
}


unescape() {
	local escEntity="$*"

	local entity=
	local escaped=0

	for i in $(seq 0 $(( ${#escEntity} - 1 ))); do
		local curChar="${escEntity:$i:1}"

		if [ $escaped -eq 1 ]; then
			if [ "$curChar" = n ]; then
				printf -v entity '%s\n' "$entity"
			else
				entity="$entity$curChar"
			fi

			escaped=0
		else
			if [ "$curChar" = \\ ]; then
				escaped=1
			else
				entity="$entity$curChar"
			fi
		fi
	done

	printf '%s' "$entity"
}


process_chksum_issue() {
	local issue="$1"
	local repl="$2"
	local obj="$3"

	if [ "${issue// /}" = t ]; then
		local err retCode
		err="$(ichksum --silent -n "$repl" "$obj" 2>&1 > /dev/null)"
		retCode="$?"

		if [[ "$err" =~ 'does not exist' ]]; then
			printf '%s' "${issue/%  /ðŸ‘» }"
		elif [[ "$retCode" -eq 0 ]] && [[ -z "$err" ]]; then
			printf '%s' "${issue/%  /âœ“ }"
		else
			if [[ -n "$err" ]]; then
				echo "$err" >&2
			fi

			printf '%s' "${issue/%  /âœ— }"
			printf 'FAILED TO GENERATE CHECKSUM!! - %s\n' "$obj" >&2
		fi
	else
		printf '%s' "$issue"
	fi
}


process_perm_issue() {
	local issue="$1"
	local entity="$2"

	if [ "${issue// /}" = t ]; then
		local err
		if err="$(ichmod -M own rodsadmin "$entity" > /dev/null 2>&1)"; then
			printf '%s' "${issue/%  /âœ“ }"
		elif [[ "$err" =~ CAT_INVALID_ARGUMENT ]]; then
			printf '%s' "${issue/%  /ðŸ‘» }"
		else
			printf '%s' "${issue/%  /âœ— }"
			echo "$err" >&2
			printf 'FAILED TO ADD RODSADMIN OWN PERMISSION!! - %s\n' "$entity" >&2
		fi
	else
		printf '%s' "$issue"
	fi
}


process_uuid_issue() {
	local uuidCntField="$1"
	local entityType="$2"
	local entity="$3"

	uuidCntField="${uuidCnt#  }"
	declare -i cnt=$uuidCntField

	if [[ $cnt -eq 1 ]]; then
		printf '%s  ' "$uuidCntField"
		return 0
	fi

	local imetaFlag
	if [ "$entityType" = coll ]; then
		local imetaFlag=-C
	else
		local imetaFlag=-d
	fi

	local statusMsg
	if [[ $cnt -eq 0 ]]; then
		statusMsg="$(add_missing_uuid "$entity" "$imetaFlag")"
	else
		statusMsg="$(rm_extra_uuids "$entity" "$imetaFlag")"
	fi

	local statusFmt
	case "${statusMsg-}" in
		SUCCESS)
			statusFmt=âœ“
			;;
		MISSING)
			statusFmt=ðŸ‘»
			;;
		*)
			statusFmt=âœ—
			;;
	esac

	printf '%s%s ' "$uuidCntField" "$statusFmt"
}


add_missing_uuid() {
	local entity="$1"
	local imetaFlag="$2"

	local uuid
	uuid="$(uuidgen -t)"

	local err
	if err="$(imeta set "$imetaFlag" "$entity" ipc_UUID "$uuid" 2>&1)"; then
		printf SUCCESS
	else
		if [[ "$err" =~ (CAT_UNKNOWN_COLLECTION|CAT_UNKNOWN_FILE) ]]; then
			printf MISSING
			return 1
		else
			echo "$err" >&2
			printf 'FAILED TO ADD UUID!! - %s\n' "$entity" >&2
		fi
	fi
}


rm_extra_uuids() {
	local entity="$1"
	local imetaFlag="$2"

	local failed

	local uuidMap
	if ! uuidMap="$(get_meta_id_uuid_map "$entity" "$imetaFlag" 2>&1)"; then
		failed=failed

		if [[ "$uuidMap" = UNKNOWN_ENTITY ]]; then
			printf MISSING
		else
			echo "$uuidMap" >&2
		fi
	else
		local cnt=0

		local uuid
		while read -r _ uuid; do
			# The first UUID created will have the first DB Id
			if [[ $(( ++cnt )) -gt 1 ]]; then
				if ! imeta rm "$imetaFlag" "$entity" ipc_UUID "$uuid"; then
					failed=failed
				fi
			fi
		done <<< "$uuidMap"
	fi

	if [[ -z "${failed-}" ]]; then
		printf SUCCESS
	else
		printf 'FAILED TO REMOVE EXTRA UUIDS!! - %s\n' "$entity" >&2
	fi
}


# Retrieve UUIDs for an entity sorted by the metdata's DB Ids
get_meta_id_uuid_map() {
	local entityPath="$1"
	local imetaFlag="$2"

	local query
	if [[ "$imetaFlag" = -C ]]; then
		query="$(mk_coll_uuid_query "$entityPath")"
	else
		query="$(mk_data_uuid_query "$(dirname "$entityPath")" "$(basename "$entityPath")")"
	fi

	local results
	if ! results="$(iquest --no-page '%s %s' "$query")"; then
		return 1
	fi

	if [[ "$results" =~ CAT_NO_ROWS_FOUND ]]; then
		printf UNKNOWN_ENTITY >&2
		return 1
	fi

	echo "$results"
}


mk_coll_uuid_query() {
	local collPath="$1"

	cat <<EOF
select order(META_COLL_ATTR_ID), META_COLL_ATTR_VALUE
where META_COLL_ATTR_NAME = 'ipc_UUID' and COLL_NAME = '$collPath'"
EOF
}


mk_data_uuid_query() {
	local collPath="$1"
	local dataName="$2"

	cat <<EOF
select order(META_DATA_ATTR_ID), META_DATA_ATTR_VALUE
where META_DATA_ATTR_NAME = 'ipc_UUID' and COLL_NAME = '$collPath' and DATA_NAME = '$dataName'"
EOF
}


generate_report() {
	local cutoffTime="$1"
	local fixLog="$2"
	local errLog="$3"

	printf '\t%s DATA STORE REPAIR REPORT\n\n\n' "$cutoffTime"
	printf 'ITEMIZED REPAIR ATTEMPTS\n\n'

	local fixLogSize
	fixLogSize="$(stat --format '%s' "$fixLog")"

	if (( fixLogSize > MAX_LOG_SIZE )); then
		local reportHost
		reportHost="$(hostname --fqdn)"

		local reportLog="$TMPDIR"/"$EXEC_NAME"@"$cutoffTime".log
		mv "$fixLog" "$reportLog"

		printf '\n'
		printf 'The itemized lists of attempted repairs is too large to send by email. '
		printf 'It may be found at %s:%s\n' "$reportHost" "$reportLog"
	else
		cat "$fixLog"
	fi

	printf '\n\nREPAIR ATTEMPT FAILURES\n\n'

	local errLogSize
	errLogSize="$(stat --format '%s' "$errLog")"

	if (( errLogSize > MAX_LOG_SIZE )); then
		local reportHost
		reportHost="$(hostname --fqdn)"

		local reportErr="$TMPDIR"/"$EXEC_NAME"@"$cutoffTime".err
		mv "$errLog" "$reportErr"

		printf '\n'
		printf 'The repair attempt failure log is too large to send by email. '
		printf 'It may be found at %s:%s\n' "$reportHost" "$reportErr"
	elif (( errLogSize > 0 )); then
		cat "$errLog"
	else
		printf 'All problems were fixed.\n'
	fi
}


strip_noise() {
	while IFS= read -r; do
		if [[ -n "${DEBUG-}" ]]; then
			printf '%s\n' "$REPLY"
		else
			case "$REPLY" in
				BEGIN|CREATE*|SELECT*|ROLLBACK)
					;;
				*)
					printf '%s\n' "$REPLY"
					;;
			esac
		fi
	done
}


rm_temp_files() {
	rm --force "${TempFiles[@]}"
}


main "$@"
