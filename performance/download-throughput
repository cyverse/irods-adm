#!/bin/bash

show_help()
{
  cat <<EOF

$ExecName version $Version

Usage:
 $ExecName [options]

This script measures download throughput from the client running this script to
the CyVerse Data Store. It downloads a data object thirty times in a row, with
each download being to a new file. A report is written to stdout, while errors
and status messages are written to stderr.

Options:
 -s, --size OBJ-SIZE      the size of the data object with units in a form
                          accepted by \`truncate\`, e.g., 2MiB gives a 2
                          mebibyte file. The default is 1GiB.
 -D, --dest-dir DEST-DIR  the name of the temporary directory where the test
                          data object will be repeatedly downloaded. Defaults
                          to
                          \`\$TMPDIR/download-throughput-\`date -u -Iseconds\`.
 -S, --src-coll SRC-COLL  the collection where the temporary test data object
                          will be generated. Defaults to
                          \`ipwd\`/download-throughput-\`date -u -Iseconds\`.
 -L, --log REPORT-FILE    write report to REPORT-FILE instead of stdout.
 -h, --help               show help and exit
 -V, --version            show version and exit
 -v, --verbose            output status messages

Output:
It generates a report similar to the following.
$(tput bold)
DOWNLOAD THROUGHPUT REPORT

Execution Time:         2019-12-02T22:47:13+00:00
File Size:              10GiB

Estimated Throuphput:   85.121 MiB/s
67% Confidence Bounds:  [84.427, 85.819] MiB/s

Bounds on Measurements: [82.116, 85.775] MiB/s


Client Information

iCommands:  rods4.1.10
Memory:     16172752 kB
Cores:      8


Runs

Run   Start Time (UTC)      Duration (s)   Throughput (MiB/s)
 01   2019-12-02T22:47:14        120.022           85.316
 02   2019-12-02T22:49:15        119.380           85.775
.
.
.
 30   2019-12-02T23:46:29        119.912           85.394  $(tput sgr0)
EOF
}


set -o nounset -o pipefail

readonly ExecAbsPath=$(readlink --canonicalize "$0")
readonly ExecName=$(basename "$ExecAbsPath")
readonly Version=1

readonly NumRuns=30

StatusLog=/dev/null
ReportLog=/dev/stdout


main()
{
  local opts
  if ! opts=$(fmt_opts "$@")
  then
    show_help >&2
    return 1
  fi

  eval set -- "$opts"

  local testTime
  testTime="$(date --utc --iso-8601=seconds)"

  local size=1GiB
  local destDir="${TMPDIR:-$HOME}/download-throughput-$testTime"
  local srcColl=
  local versionReq=
  while true
  do
    case "$1" in
      -h|--help)
        show_help
        return 0
        ;;
      -V|--version)
        versionReq=1
        shift
        ;;
      -v|--verbose)
        StatusLog=/dev/stderr
        shift
        ;;
      -D|--dest-dir)
        destDir="$2"
        shift 2
        ;;
      -L|--log)
        ReportLog="$2"
        shift 2
        ;;
      -S|--src-coll)
        srcColl="$2"
        shift 2
        ;;
      -s|--size)
        size="$2"
        shift 2
        ;;
      --)
        shift
        break
        ;;
      *)
        show_help >&2
        return 1
        ;;
    esac
  done

  if [[ -n "$versionReq" ]]
  then
    printf '%s\n' "$Version"
  else
    do_test "$size" "$testTime" "$srcColl" "$destDir"
  fi
}


fmt_opts()
{
  getopt \
    --name "$ExecName" \
    --longoptions help,verbose.version,dest-dir:,log:,size:,src-coll: \
    --options hVvD:L:S:s: \
    -- \
    "$@"
}


do_test()
{
  local size="$1"
  local testTime="$2"
  local srcColl="$3"
  local destDir="$4"

  if ! ensure_irods_sess
  then
    printf 'iRODS session not initialized\n' >&2
    return 1
  fi

  if [[ -z "$srcColl" ]]
  then
    srcColl="$(ipwd)/download-throughput-$testTime"
  fi

  # shellcheck disable=SC2064
  trap "clean_up '$srcColl' '$destDir'" EXIT

  printf 'Creating source collection %s\n' "$srcColl" >> "$StatusLog"
  if ! imkdir "$srcColl"
  then
    printf 'Failed to create source collection\n' >&2
    return 1
  fi

  printf 'Creating destination directory %s\n' "$destDir" >> "$StatusLog"
  if ! mkdir "$destDir"
  then
    printf 'Cannot create destination directory\n' >&2
    return 1
  fi

  local srcFile
  if ! srcFile=$(TMPDIR="$destDir" mktemp)
  then
    printf 'Cannot reserve temporary file\n' >&2
    return 1
  fi

  printf 'Creating test file\n' >> "$StatusLog"
  if ! truncate --size "$size" "$srcFile"
  then
    printf 'Failed to create file\n' >&2
    return 1
  fi

  local srcObj="$srcColl"/test_file
  printf 'Staging test file\n' >> "$StatusLog"
  if ! iput "$srcFile" "$srcObj"
  then
    printf 'Failed to stage test file\n' >&2
    return 1
  fi

  rm --force "$srcFile"

  printf 'Beginning test\n' >> "$StatusLog"

  local attempt
  for attempt in $(seq "$NumRuns")
  do
    printf 'Downloading %s\n' "$attempt" >> "$StatusLog"

    local destFile
    printf -v destFile '%s/download-%02d' "$destDir" "$attempt"
    perform_download "$attempt" "$srcObj" "$destFile" | tee --append "$StatusLog"
    rm --force "$destFile"
  done | gen_report "$testTime" "$size" > "$ReportLog"

  printf 'Finished test\n' >> "$StatusLog"
}


perform_download()
{
  local run="$1"
  local src="$2"
  local dest="$3"

  local startTime duration rate
  startTime=$(date --utc --iso-8601=seconds)
  IFS=' |' read -r _ _ _ duration _ _ _ rate _ < <(iget -v "$src" "$dest")
  printf '%d %s %s %s\n' "$run" "$startTime" "$duration" "$rate"
}


clean_up()
{
  local srcColl="$1"
  local destDir="$2"

  printf 'Deleting destination directory %s\n' "$destDir" >> "$StatusLog"
  rm --force --recursive "$destDir"

  if ils "$srcColl" &> /dev/null
  then
    printf 'Deleting source collection %s\n' "$srcColl" >> "$StatusLog"
    irm -f -r "$srcColl"
  fi

  printf 'Finished\n' >> "$StatusLog"
  return 0
}


ensure_irods_sess()
{
  local authFile
  authFile="$(ienv | sed --quiet 's/.*irods_authentication_file - //p')"

  if [[ -z "$authFile" ]] || [[ ! -e "$authFile" ]]
  then
    if ! iinit
    then
      iexit full
      return 1
    fi
  fi
}


gen_report()
{
  local reportTime="$1"
  local size="$2"

  local rates=()

  local runsReport
  printf -v runsReport 'Runs\n\n'

  printf -v runsReport \
    '%sRun   Start Time (UTC)      Duration (s)   Throughput (MiB/s)\n' "$runsReport"

  local duration rate run startTime
  while IFS=' ' read -r run startTime duration rate
  do
    rates=(${rates[*]} $rate)
    startTime="${startTime%+*}"

    printf -v runsReport \
      '%s %02d   %s   %12s   %14s\n' "$runsReport" "$run" "$startTime" "$duration" "$rate"
  done

  local maxRate minRate
  maxRate=$(compute_max "${rates[@]}")
  minRate=$(compute_min "${rates[@]}")

  local geoMeanRate geoStd
  geoMeanRate=$(compute_geomean "${rates[@]}")
  geoStd=$(compute_geostd "$geoMeanRate" "${rates[@]}")

  local expectedRate likelyLB likelyUB
  expectedRate=$(dc --expression "3 k $geoMeanRate 1 / p")
  likelyLB=$(dc --expression "3 k $geoMeanRate $geoStd / p")
  likelyUB=$(dc --expression "3 k $geoMeanRate $geoStd * 1 / p")

  local irodsVer numCores totMem
  numCores=$(grep --count --regexp '^processor' /proc/cpuinfo)
  totMem=$(awk '/MemTotal:/ { printf "%s %s", $2, $3 }' /proc/meminfo)
  irodsVer=$(ienv | sed --quiet 's/.*Release Version = \([^,]*\),.*/\1/p')

  local reportSize
  reportSize=$(sed 's/^\([0-9]*\)/\1 /' <<<"$size")

  local report
  printf -v report 'DOWNLOAD THROUGHPUT REPORT\n\n'

  printf -v report '%sExecution Time:         %s\n' "$report" "$reportTime"
  printf -v report '%sFile Size:              %s\n\n' "$report" "$reportSize"
  printf -v report '%sEstimated Throuphput:   %s MiB/s\n' "$report" "${expectedRate/#./0.}"
  printf -v report '%s67%% Confidence Bounds:  [%s, %s] MiB/s\n\n' \
    "$report" "${likelyLB/#./0.}" "${likelyUB/#./0.}"

  printf -v report '%sBounds on Measurements: [%s, %s] MiB/s\n' "$report" "$minRate" "$maxRate"

  printf -v report '%s\n\nClient Information\n\n' "$report"
  printf -v report '%siCommands:  %s\n' "$report" "$irodsVer"
  printf -v report '%sMemory:     %s\n' "$report" "$totMem"
  printf -v report '%sCores:      %d\n' "$report" "$numCores"

  printf '%s\n\n%s' "$report" "$runsReport"
}


compute_geomean()
{
  awk --file - <(printf '%s\n' "$@") <<'EOF'
    BEGIN { totLn = 0.0; }
    { totLn += log($0); }
    END { print exp(totLn / NR); }
EOF
}


compute_geostd()
{
  local geoMean="$1"
  shift

  awk --assign GEOMEAN="$geoMean" --file - <(printf '%s\n' "$@") <<'EOF'
    BEGIN { totSqrLnScaled = 0.0; }
    GEOMEAN == 0 { totSqrLnScaled = +inf }
    GEOMEAN != 0 { totSqrLnScaled += log($0 / GEOMEAN)^2 }
    END { print exp(sqrt(totSqrLnScaled / NR)); }
EOF
}

compute_max()
{
  awk --file - <(printf '%s\n' "$@") <<'EOF'
    NR == 1 { max = $0; }
    { if ($0 > max) { max = $0; } }
    END { print max; }
EOF
}

compute_min()
{
  awk --file - <(printf '%s\n' "$@") <<'EOF'
    NR == 1 { min = $0; }
    { if ($0 < min) { min = $0; } }
    END { print min; }
EOF
}


main "$@"
